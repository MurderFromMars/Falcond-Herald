#!/usr/bin/env python3
"""
Falcond Herald - Power Profile Notification Daemon
A companion service that announces Falcond's power profile changes
via desktop notifications.

Supports:
  - power-profiles-daemon (standard)
  - tuned-ppd (Fedora/RHEL compatibility layer)
  - Any D-Bus service implementing net.hadess.PowerProfiles

Works with any DE/WM that has a notification daemon:
  - KDE Plasma, GNOME, XFCE, Cinnamon, MATE, LXQt
  - Hyprland, Sway, i3, bspwm (with dunst, mako, swaync, etc.)
"""

import os
import sys
import signal
import subprocess
import shutil
from pathlib import Path

try:
    import dbus
    from dbus.mainloop.glib import DBusGMainLoop
    from gi.repository import GLib
except ImportError as e:
    print(f"Error: Missing dependency - {e}")
    print("Please install: python3-dbus python3-gi")
    sys.exit(1)


# Notification Configuration
PROFILES = {
    "performance": {
        "title": "âš¡ Falcond Herald",
        "message": "Performance Optimization Activated",
        "icon": "power-profile-performance-symbolic",
        "urgency": "normal"
    },
    "balanced": {
        "title": "ðŸ”‹ Falcond Herald",
        "message": "Resuming standard desktop power profile",
        "icon": "power-profile-balanced-symbolic",
        "urgency": "low"
    },
    "power-saver": {
        "title": "ðŸƒ Falcond Herald",
        "message": "Power conservation mode engaged",
        "icon": "power-profile-power-saver-symbolic",
        "urgency": "low"
    }
}

# Fallback icons (more universally available)
FALLBACK_ICONS = {
    "performance": "battery-full-charged",
    "balanced": "battery-good",
    "power-saver": "battery-low"
}

# D-Bus constants - same interface for power-profiles-daemon AND tuned-ppd
PPD_BUS_NAME = "net.hadess.PowerProfiles"
PPD_OBJECT_PATH = "/net/hadess/PowerProfiles"
PPD_INTERFACE = "net.hadess.PowerProfiles"
DBUS_PROPERTIES_INTERFACE = "org.freedesktop.DBus.Properties"


class FalcondHerald:
    def __init__(self):
        self.loop = None
        self.bus = None
        self.current_profile = None
        self.first_run = True
        
    def send_notification(self, profile: str) -> None:
        """Send a desktop notification for the given power profile."""
        config = PROFILES.get(profile, {
            "title": "ðŸ”Œ Falcond Herald",
            "message": f"Power profile changed to: {profile}",
            "icon": "battery",
            "urgency": "normal"
        })
        
        # Try symbolic icon first, fall back to standard icon
        icon = config["icon"]
        fallback_icon = FALLBACK_ICONS.get(profile, "battery")
        
        # Build notification command
        cmd = [
            "notify-send",
            "--app-name=Falcond Herald",
            f"--urgency={config['urgency']}",
            f"--icon={icon}",
            config["title"],
            config["message"]
        ]
        
        try:
            # Set up environment for user session notifications
            env = os.environ.copy()
            
            # Ensure we can reach the notification daemon
            # Works for both X11 and Wayland sessions
            if "DISPLAY" not in env and "WAYLAND_DISPLAY" not in env:
                # Try common defaults
                env["DISPLAY"] = ":0"
            
            # For Wayland compositors, ensure XDG_RUNTIME_DIR is set
            if "XDG_RUNTIME_DIR" not in env:
                uid = os.getuid()
                runtime_dir = f"/run/user/{uid}"
                if os.path.exists(runtime_dir):
                    env["XDG_RUNTIME_DIR"] = runtime_dir
            
            result = subprocess.run(cmd, env=env, capture_output=True, timeout=5)
            
            # If symbolic icon failed, retry with fallback
            if result.returncode != 0 and icon != fallback_icon:
                cmd[4] = f"--icon={fallback_icon}"
                subprocess.run(cmd, env=env, capture_output=True, timeout=5)
                
        except subprocess.TimeoutExpired:
            print(f"Warning: Notification timed out for profile: {profile}")
        except FileNotFoundError:
            print("Warning: notify-send not found. Install libnotify.")
        except Exception as e:
            print(f"Warning: Failed to send notification: {e}")
    
    def on_properties_changed(self, interface: str, changed: dict, invalidated: list) -> None:
        """Handle D-Bus property changes."""
        if interface != PPD_INTERFACE:
            return
            
        if "ActiveProfile" in changed:
            new_profile = str(changed["ActiveProfile"])
            
            # Skip notification on first detection (startup)
            if self.first_run:
                self.first_run = False
                self.current_profile = new_profile
                print(f"Herald standing by. Current profile: {new_profile}")
                return
            
            if new_profile != self.current_profile:
                print(f"Announcing: {self.current_profile} -> {new_profile}")
                self.current_profile = new_profile
                self.send_notification(new_profile)
    
    def get_current_profile(self) -> str:
        """Get the current active power profile."""
        try:
            proxy = self.bus.get_object(PPD_BUS_NAME, PPD_OBJECT_PATH)
            props = dbus.Interface(proxy, DBUS_PROPERTIES_INTERFACE)
            return str(props.Get(PPD_INTERFACE, "ActiveProfile"))
        except dbus.DBusException as e:
            print(f"Error getting current profile: {e}")
            return "unknown"
    
    def detect_backend(self) -> str:
        """Detect which power profile backend is running."""
        try:
            # Check for tuned-ppd first (it's a shim over tuned)
            result = subprocess.run(
                ["systemctl", "is-active", "tuned-ppd"],
                capture_output=True, timeout=5
            )
            if result.returncode == 0:
                return "tuned-ppd"
        except:
            pass
        
        try:
            # Check for power-profiles-daemon
            result = subprocess.run(
                ["systemctl", "is-active", "power-profiles-daemon"],
                capture_output=True, timeout=5
            )
            if result.returncode == 0:
                return "power-profiles-daemon"
        except:
            pass
        
        return "unknown"
    
    def check_ppd_available(self) -> bool:
        """Check if power-profiles-daemon is available."""
        try:
            proxy = self.bus.get_object(PPD_BUS_NAME, PPD_OBJECT_PATH)
            props = dbus.Interface(proxy, DBUS_PROPERTIES_INTERFACE)
            props.Get(PPD_INTERFACE, "ActiveProfile")
            return True
        except dbus.DBusException:
            return False
    
    def setup_signal_handlers(self) -> None:
        """Set up signal handlers for graceful shutdown."""
        def handle_signal(signum, frame):
            print(f"\nReceived signal {signum}, Herald retiring...")
            if self.loop:
                self.loop.quit()
        
        signal.signal(signal.SIGINT, handle_signal)
        signal.signal(signal.SIGTERM, handle_signal)
    
    def run(self) -> int:
        """Main daemon loop."""
        print("Falcond Herald - Power Profile Announcer")
        print("========================================")
        
        # Initialize D-Bus with GLib main loop
        DBusGMainLoop(set_as_default=True)
        
        try:
            self.bus = dbus.SystemBus()
        except dbus.DBusException as e:
            print(f"Error: Cannot connect to system D-Bus: {e}")
            return 1
        
        # Check if power-profiles-daemon (or tuned-ppd) is available
        if not self.check_ppd_available():
            print("Error: No power profile daemon available.")
            print("")
            print("Install ONE of the following:")
            print("")
            print("  power-profiles-daemon (recommended):")
            print("    Arch:          sudo pacman -S power-profiles-daemon")
            print("    Debian/Ubuntu: sudo apt install power-profiles-daemon")
            print("    Fedora:        sudo dnf install power-profiles-daemon")
            print("")
            print("  tuned-ppd (Fedora/RHEL alternative):")
            print("    Fedora:        sudo dnf install tuned-ppd")
            print("    RHEL/CentOS:   sudo dnf install tuned-ppd")
            print("")
            print("Then enable: sudo systemctl enable --now <service-name>")
            return 1
        
        # Get initial profile
        self.current_profile = self.get_current_profile()
        backend = self.detect_backend()
        print(f"Backend: {backend}")
        print(f"Current power profile: {self.current_profile}")
        print("Awaiting Falcond's commands...")
        
        # Subscribe to property changes
        self.bus.add_signal_receiver(
            self.on_properties_changed,
            signal_name="PropertiesChanged",
            dbus_interface=DBUS_PROPERTIES_INTERFACE,
            bus_name=PPD_BUS_NAME,
            path=PPD_OBJECT_PATH
        )
        
        # Set up signal handlers
        self.setup_signal_handlers()
        
        # Run main loop
        self.loop = GLib.MainLoop()
        try:
            self.loop.run()
        except KeyboardInterrupt:
            pass
        
        print("Falcond Herald stopped.")
        return 0


def main():
    daemon = FalcondHerald()
    sys.exit(daemon.run())


if __name__ == "__main__":
    main()
