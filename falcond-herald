#!/usr/bin/env python3

####A companion service that announces Falcond's power profile changes.




import os
import sys
import signal
import subprocess
from pathlib import Path
from datetime import datetime

try:
    import dbus
    from dbus.mainloop.glib import DBusGMainLoop
    # Import Notify for advanced notification control
    from gi.repository import GLib, Notify
except ImportError as e:
    print(f"Error: Missing dependency - {e}")
    print("Please install: python3-dbus python3-gi libnotify")
    sys.exit(1)


# Notification Configuration
PROFILES = {
    "performance": {
        "title": "Falcond",
        "message": "Performance Optimizations Active",
        "icon": "weather-storm-symbolic"  # Lightning bolt (fallback: input-gaming-symbolic)
    },
    "balanced": {
        "title": "Falcond",
        "message": "Standard Performance Restored",
        "icon": "emblem-default-symbolic" # Checkmark/Standard (fallback: user-available-symbolic)
    },
    "power-saver": {
        "title": "Falcond",
        "message": "Low Power Mode Active.",
        "icon": "night-light-symbolic"    # Moon/Night (fallback: battery-low-symbolic)
    }
}

# D-Bus constants
PPD_BUS_NAME = "net.hadess.PowerProfiles"
PPD_OBJECT_PATH = "/net/hadess/PowerProfiles"
PPD_INTERFACE = "net.hadess.PowerProfiles"
DBUS_PROPERTIES_INTERFACE = "org.freedesktop.DBus.Properties"

# Logging
LOG_DIR = Path.home() / ".local" / "share" / "falcond-herald"
LOG_FILE = LOG_DIR / "falcond-herald.log"
PID_FILE = LOG_DIR / "falcond-herald.pid"


class FalcondHerald:
    def __init__(self):
        self.loop = None
        self.bus = None
        self.current_profile = None
        self.first_run = True

        # Setup logging directory
        LOG_DIR.mkdir(parents=True, exist_ok=True)
        
        # Write PID file
        with open(PID_FILE, 'w') as f:
            f.write(str(os.getpid()))

        # Setup logging
        self.log_file = open(LOG_FILE, 'a')
        self.log("Falcond Herald starting...")

        # Init notification system
        try:
            if not Notify.init("Falcond"):
                self.log("Warning: Failed to initialize libnotify")
        except Exception as e:
            self.log(f"Warning: Notify init error: {e}")

    def log(self, message: str):
        """Write log message with timestamp."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_line = f"[{timestamp}] {message}\n"
        self.log_file.write(log_line)
        self.log_file.flush()
        print(f"[{timestamp}] {message}")

    def send_notification(self, profile: str) -> None:
        """
        Send a Critical notification that auto-closes.
        """
        config = PROFILES.get(profile, {
            "title": "Falcond",
            "message": f"Profile Active: {profile}",
            "icon": "emblem-system-symbolic"
        })

        try:
            # Create the notification object
            n = Notify.Notification.new(
                config["title"],
                config["message"],
                config["icon"]
            )

            # SET URGENCY TO CRITICAL (2)
            # This forces the notification to appear even in fullscreen games
            n.set_urgency(Notify.Urgency.CRITICAL)

            # Show the notification
            n.show()

            # FORCE CLOSE AFTER 6 SECONDS (6000ms)
            GLib.timeout_add(6000, n.close)

            self.log(f"Notification sent: {config['message']}")

        except Exception as e:
            self.log(f"Failed to show notification: {e}")
            # Fallback: Try simple notify-send if the Python method fails
            try:
                subprocess.run([
                    "notify-send",
                    "--urgency=critical",
                    "--expire-time=6000",
                    f"--icon={config['icon']}",
                    config["title"],
                    config["message"]
                ])
            except:
                pass

    def on_properties_changed(self, interface: str, changed: dict, invalidated: list) -> None:
        """Handle D-Bus property changes."""
        if interface != PPD_INTERFACE:
            return

        if "ActiveProfile" in changed:
            new_profile = str(changed["ActiveProfile"])

            # Skip notification on first detection (startup)
            if self.first_run:
                self.first_run = False
                self.current_profile = new_profile
                self.log(f"Herald standing by. Current profile: {new_profile}")
                return

            if new_profile != self.current_profile:
                self.log(f"Profile change: {self.current_profile} -> {new_profile}")
                self.current_profile = new_profile
                self.send_notification(new_profile)

    def get_current_profile(self) -> str:
        """Get the current active power profile."""
        try:
            proxy = self.bus.get_object(PPD_BUS_NAME, PPD_OBJECT_PATH)
            props = dbus.Interface(proxy, DBUS_PROPERTIES_INTERFACE)
            return str(props.Get(PPD_INTERFACE, "ActiveProfile"))
        except dbus.DBusException as e:
            self.log(f"Error getting current profile: {e}")
            return "unknown"

    def check_ppd_available(self) -> bool:
        """Check if power-profiles-daemon is available on D-Bus."""
        try:
            proxy = self.bus.get_object(PPD_BUS_NAME, PPD_OBJECT_PATH)
            props = dbus.Interface(proxy, DBUS_PROPERTIES_INTERFACE)
            props.Get(PPD_INTERFACE, "ActiveProfile")
            return True
        except dbus.DBusException:
            return False

    def setup_signal_handlers(self) -> None:
        """Set up signal handlers for graceful shutdown."""
        def handle_signal(signum, frame):
            self.log(f"Received signal {signum}, shutting down...")
            if self.loop:
                self.loop.quit()
            try: 
                Notify.uninit()
            except: 
                pass
            try:
                self.log_file.close()
            except:
                pass
            try:
                PID_FILE.unlink()
            except:
                pass

        signal.signal(signal.SIGINT, handle_signal)
        signal.signal(signal.SIGTERM, handle_signal)

    def run(self) -> int:
        """Main daemon loop."""
        self.log("Falcond Herald - Active")
        self.log("=======================")

        DBusGMainLoop(set_as_default=True)

        try:
            self.bus = dbus.SystemBus()
        except dbus.DBusException as e:
            self.log(f"Error: Cannot connect to system D-Bus: {e}")
            return 1

        if not self.check_ppd_available():
            self.log("Error: No power profile daemon available on D-Bus.")
            return 1

        self.current_profile = self.get_current_profile()
        self.log(f"Current profile: {self.current_profile}")

        self.bus.add_signal_receiver(
            self.on_properties_changed,
            signal_name="PropertiesChanged",
            dbus_interface=DBUS_PROPERTIES_INTERFACE,
            bus_name=PPD_BUS_NAME,
            path=PPD_OBJECT_PATH
        )

        self.setup_signal_handlers()

        self.loop = GLib.MainLoop()
        try:
            self.loop.run()
        except KeyboardInterrupt:
            pass

        return 0

def main():
    daemon = FalcondHerald()
    sys.exit(daemon.run())

if __name__ == "__main__":
    main()
